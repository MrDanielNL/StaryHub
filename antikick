task.wait(3) -- Wait for game to load properly

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
if not player then
    repeat task.wait() player = Players.LocalPlayer until player
end

local mt = getrawmetatable(game)
setreadonly(mt, false)

local oldNamecall = mt.__namecall
local oldIndex = mt.__index
local oldNewIndex = mt.__newindex

-- Metamethod protections
mt.__namecall = newcclosure(function(self, ...)
    local method = getnamecallmethod()
    if self == player and (method == "Kick" or method == "Destroy" or method == "BreakJoints") then
        warn("[AK] Blocked method:", method)
        return nil
    end
    return oldNamecall(self, ...)
end)

mt.__index = newcclosure(function(self, key)
    if self == player and key == "Kick" then
        warn("[AK] Blocked .Kick access")
        return function() end
    end
    return oldIndex(self, key)
end)

mt.__newindex = newcclosure(function(self, key, value)
    if self == player and key == "Kick" then
        warn("[AK] Blocked setting .Kick")
        return
    end
    return oldNewIndex(self, key, value)
end)

-- Direct Kick override
player.Kick = function()
    warn("[AK] Kick attempt blocked.")
end

-- Disable Kick connections safely
if getconnections and typeof(player.Kick) == "RBXScriptSignal" then
    for _, conn in ipairs(getconnections(player.Kick)) do
        pcall(function() conn:Disable() end)
        warn("[AK] Disabled Kick connection.")
    end
end

-- Reapply protection if something tries to reset it
task.spawn(function()
    while true do
        player.Kick = function() end
        task.wait(2)
    end
end)
